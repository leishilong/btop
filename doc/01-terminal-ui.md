# 1. 终端 UI（不依赖 ncurses）实现详解

目标：理解如何在不使用 `ncurses` 的情况下，利用原始 ANSI 控制码构建高性能终端 UI，并掌握避免闪烁、真彩色输出与高效重绘的技巧。

相关文件：`src/btop_draw.cpp`, `src/btop_tools.cpp`, `src/btop.hpp`

一、总体思路
- btop 采用手写 ANSI 控制序列（如 `\x1b[...m`, `\x1b[H`, `\x1b[J` 等）直接控制终端，而不是依赖 `ncurses`。这样做的好处：更小的抽象开销、更精细的控制（例如精确控制光标与颜色），并且可以按需做优化（减少系统调用、合并输出）。

二、真彩色（TrueColor，24-bit）实现
- ANSI 真彩色格式：`\x1b[38;2;<r>;<g>;<b>m`（前景色）或 `\x1b[48;2;<r>;<g>;<b>m`（背景色）。
- btop 在 theme/颜色逻辑层计算需要的 RGB，并把它格式化成上述序列写入输出缓冲区。关键点：
  - 避免每个字符都输出颜色序列；只在颜色变化处插入颜色切换序列。
  - 合并同一行或同一块的输出以减少写调用（见 `btop_draw.cpp` 中如何构造整段字符串再一次性写入）。

示例：
```
// 前景真彩色示例
std::string set = "\x1b[38;2;" + to_string(r) + ";" + to_string(g) + ";" + to_string(b) + "m";
out += set + text + "\x1b[0m"; // 恢复
```

三、避免屏幕闪烁（双缓冲 vs 单次输出）
- 传统两种方式：
  1. 双缓冲（在内存构建完整帧，然后替换屏幕）
  2. 差分更新（只更新变化区域）
- btop 的策略：
  - 在内存构建要输出的区域（例如构建整个 box 或整行字符串），然后用一次写调用刷入终端，从而做到“近似双缓冲”的效果，但避免全屏重绘造成的昂贵操作。
  - 使用 `terminal_sync` 与 `Term::sync_start`/`sync_end` 类似的机制在需要时包裹输出（见 `btop.cpp` 中 term_sync 判断）。
  - 差异化重绘：仅当数据或布局变化时才重绘对应 box，避免不必要的 I/O。

四、高效计算字符位置与重绘区域
- 关键原则：最小化需要更新的字符范围。
  - 把界面切成 boxes（cpu/mem/net/proc 等），每个 box 有自己的尺寸与位置；发生变化时只重画对应 box。
  - 使用预计算的字符宽度与坐标映射（见 `Term::` / `Draw::calcSizes()`），减少在绘制时做昂贵计算。
  - 宽字符（widechar）处理：btop 使用 `include/widechar_width.hpp`（或自定义函数）来计算字符列宽，确保在计算列索引时正确对齐。

五、实践建议与验证
- 在 `btop_draw.cpp` 加入计时输出（Logger::debug）来测量每个 box 的构建与输出时间。观察是否存在单个 box 输出极慢导致 UI 卡顿。
- 在终端里用 `script` 或重定向捕获程序输出，确认颜色序列最小化与输出合并。

六、学习价值总结
- 学会用“字符串缓冲 + 一次性写入”替代传统 UI 库的频繁系统调用；掌握真彩色 ANSI 序列的构成；学会分区/差分重绘以降低 I/O 开销。
